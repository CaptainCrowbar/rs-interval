#include "rs-intervals/types.hpp"
#include "test/unit-test.hpp"

using namespace RS::Intervals;
using namespace RS::Intervals::Detail;

using B = Boundary<double>;
using BT = BoundaryType;

void test_rs_interval_continuous_boundary_multiplication() {

    static const B none = {0, BT::empty};
    static const B ninf = {0, BT::minus_infinity};
    static const B pinf = {0, BT::plus_infinity};
    static const B cl0 = {0, BT::closed};
    static const B op0 = {0, BT::open};
    static const B cl2 = {2, BT::closed};
    static const B op2 = {2, BT::open};
    static const B cl3 = {3, BT::closed};
    static const B op3 = {3, BT::open};
    static const B cl6 = {6, BT::closed};
    static const B op6 = {6, BT::open};
    static const B cl_2 = {-2, BT::closed};
    static const B op_2 = {-2, BT::open};
    static const B cl_3 = {-3, BT::closed};
    static const B op_3 = {-3, BT::open};
    static const B cl_6 = {-6, BT::closed};
    static const B op_6 = {-6, BT::open};

    TEST_EQUAL(none * none, none);
    TEST_EQUAL(none * ninf, none);
    TEST_EQUAL(none * pinf, none);
    TEST_EQUAL(none * cl_3, none);
    TEST_EQUAL(none * cl3, none);
    TEST_EQUAL(none * cl0, none);
    TEST_EQUAL(none * op_3, none);
    TEST_EQUAL(none * op3, none);
    TEST_EQUAL(none * op0, none);
    TEST_EQUAL(ninf * none, none);
    TEST_EQUAL(ninf * ninf, pinf);
    TEST_EQUAL(ninf * pinf, ninf);
    TEST_EQUAL(ninf * cl_3, pinf);
    TEST_EQUAL(ninf * cl3, ninf);
    TEST_EQUAL(ninf * cl0, cl0);
    TEST_EQUAL(ninf * op_3, pinf);
    TEST_EQUAL(ninf * op3, ninf);
    TEST_EQUAL(ninf * op0, op0);
    TEST_EQUAL(pinf * none, none);
    TEST_EQUAL(pinf * ninf, ninf);
    TEST_EQUAL(pinf * pinf, pinf);
    TEST_EQUAL(pinf * cl_3, ninf);
    TEST_EQUAL(pinf * cl3, pinf);
    TEST_EQUAL(pinf * cl0, cl0);
    TEST_EQUAL(pinf * op_3, ninf);
    TEST_EQUAL(pinf * op3, pinf);
    TEST_EQUAL(pinf * op0, op0);
    TEST_EQUAL(cl_2 * none, none);
    TEST_EQUAL(cl_2 * ninf, pinf);
    TEST_EQUAL(cl_2 * pinf, ninf);
    TEST_EQUAL(cl_2 * cl_3, cl6);
    TEST_EQUAL(cl_2 * cl3, cl_6);
    TEST_EQUAL(cl_2 * cl0, cl0);
    TEST_EQUAL(cl_2 * op_3, op6);
    TEST_EQUAL(cl_2 * op3, op_6);
    TEST_EQUAL(cl_2 * op0, op0);
    TEST_EQUAL(cl2 * none, none);
    TEST_EQUAL(cl2 * ninf, ninf);
    TEST_EQUAL(cl2 * pinf, pinf);
    TEST_EQUAL(cl2 * cl_3, cl_6);
    TEST_EQUAL(cl2 * cl3, cl6);
    TEST_EQUAL(cl2 * cl0, cl0);
    TEST_EQUAL(cl2 * op_3, op_6);
    TEST_EQUAL(cl2 * op3, op6);
    TEST_EQUAL(cl2 * op0, op0);
    TEST_EQUAL(cl0 * none, none);
    TEST_EQUAL(cl0 * ninf, cl0);
    TEST_EQUAL(cl0 * pinf, cl0);
    TEST_EQUAL(cl0 * cl_3, cl0);
    TEST_EQUAL(cl0 * cl3, cl0);
    TEST_EQUAL(cl0 * cl0, cl0);
    TEST_EQUAL(cl0 * op_3, cl0);
    TEST_EQUAL(cl0 * op3, cl0);
    TEST_EQUAL(cl0 * op0, cl0);
    TEST_EQUAL(op_2 * none, none);
    TEST_EQUAL(op_2 * ninf, pinf);
    TEST_EQUAL(op_2 * pinf, ninf);
    TEST_EQUAL(op_2 * cl_3, op6);
    TEST_EQUAL(op_2 * cl3, op_6);
    TEST_EQUAL(op_2 * cl0, cl0);
    TEST_EQUAL(op_2 * op_3, op6);
    TEST_EQUAL(op_2 * op3, op_6);
    TEST_EQUAL(op_2 * op0, op0);
    TEST_EQUAL(op2 * none, none);
    TEST_EQUAL(op2 * ninf, ninf);
    TEST_EQUAL(op2 * pinf, pinf);
    TEST_EQUAL(op2 * cl_3, op_6);
    TEST_EQUAL(op2 * cl3, op6);
    TEST_EQUAL(op2 * cl0, cl0);
    TEST_EQUAL(op2 * op_3, op_6);
    TEST_EQUAL(op2 * op3, op6);
    TEST_EQUAL(op2 * op0, op0);
    TEST_EQUAL(op0 * none, none);
    TEST_EQUAL(op0 * ninf, op0);
    TEST_EQUAL(op0 * pinf, op0);
    TEST_EQUAL(op0 * cl_3, op0);
    TEST_EQUAL(op0 * cl3, op0);
    TEST_EQUAL(op0 * cl0, cl0);
    TEST_EQUAL(op0 * op_3, op0);
    TEST_EQUAL(op0 * op3, op0);
    TEST_EQUAL(op0 * op0, op0);

}
